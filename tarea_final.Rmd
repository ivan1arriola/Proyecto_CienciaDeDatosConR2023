---
title: "Tarea Final"
author: "Arriola, Miquelerena, Rovetta"
date: "`r Sys.Date()`"
output: pdf_document
bibliography: [packages.bib,bibliografia.bib]
nocite: '@*'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r Librerias , include = FALSE}
library(tidyverse)
library(DBI)
library(RPostgres)
library(sf)
library(leaflet)
library(paletteer)
library(geouy)
library(spdep)
library(leaflet)
library(xtable)
source(here::here("app", "utils.R"))
```

```{r Variables de Entorno, eval=FALSE, echo=FALSE}
usethis::edit_r_environ(
  scope = "project"
)
```

# Introducción

Datos de trafico

# Datos

## Descripción general de los datos

Los datos utilizados son estos

-   [Conteo vehicular en las principales avenidas de Montevideo](https://catalogodatos.gub.uy/dataset/intendencia-montevideo-conteo-de-vehiculos-del-centro-de-gestion-de-la-movilidad)
-   [Velocidad promedio vehicular en las principales avenidas de Montevideo](https://catalogodatos.gub.uy/dataset/intendencia-montevideo-velocidad-promedio-vehicular-en-las-principales-avenidas-de-montevideo)
-   [Ubicación de sensores de medición de conteo vehículos](https://catalogodatos.gub.uy/dataset/intendencia-montevideo-ubicacion-de-sensores-de-medicion-de-conteo-vehiculos)
-   [Semaforos](https://geoweb.montevideo.gub.uy/geonetwork/srv/spa/catalog.search#/metadata/d2da8cdd-c718-4eeb-9825-7069498b29c2)

Todos provenientes de la Intendencia de Montevideo

### Observaciones

Los datos son mensuales. Van desde Enero 2021 hasta Abril 2023. Los datos de los semaforos son de septiembre del 2014

### Descripcion de variables

**Conjunto de datos: Conteo vehicular en las principales avenidas de Montevideo**

-   `cod_detector`: Entero - ID de la cámara que monitorea un carril específico para detectar vehículos.
-   `id_carril`: Entero - Número del carril monitoreado (1, 2, 3, ...).
-   `fecha`: AAAA-MM-DD - Día en que se realizó la medición.
-   `hora`: hh:mm:ss - Hora en que se realizó la medición.
-   `dsc_avenida`: Texto - Nombre de la avenida donde se mide el tráfico.
-   `dsc_int_anterior`: Texto - Nombre de la vía desde donde vienen los vehículos.
-   `dsc_int_siguiente`: Texto - Nombre de la vía hacia donde se dirigen los vehículos.
-   `latitud`: Float - Latitud del lugar de medición.
-   `longitud`: Float - Longitud del lugar de medición.
-   `volumen`: Entero - Cantidad de vehículos detectados en el carril en los últimos 5 minutos.
-   `volumen_hora`: Entero - Cantidad de vehículos detectados en el carril en la última hora.

**Conjunto de datos: Velocidad promedio vehicular en las principales avenidas de Montevideo**

-   `cod_detector`: Entero - ID de la cámara que monitorea un carril específico para detectar vehículos.
-   `id_carril`: Entero - Número del carril monitoreado (1, 2, 3, ...).
-   `fecha`: AAAA-MM-DD - Día en que se realizó la medición.
-   `hora`: hh:mm:ss - Hora en que se realizó la medición.
-   `dsc_avenida`: Texto - Nombre de la avenida donde se mide el tráfico.
-   `dsc_int_anterior`: Texto - Nombre de la vía desde donde vienen los vehículos.
-   `dsc_int_siguiente`: Texto - Nombre de la vía hacia donde se dirigen los vehículos.
-   `latitud`: Float - Latitud del lugar de medición.
-   `longitud`: Float - Longitud del lugar de medición.
-   `velocidad_promedio`: Entero - Promedio de las velocidades de los autos que circularon por el carril durante los últimos 5 minutos.

**Conjunto de datos: Ubicación de sensores de medición de conteo vehículos**

-   `dsc_avenida`: Texto - Nombre de la avenida donde se encuentra el sensor o cámara y donde se mide el tránsito.
-   `dsc_int_anterior`: Texto - Nombre de la vía que forma el cruce desde donde vienen los vehículos.
-   `dsc_int_siguiente`: Texto - Nombre de la vía que forma el cruce donde está el sensor. En general, el sensor se encuentra un poco antes de esta vía. El sentido de circulación será desde el cruce con `dsc_int_anterior` hacia el cruce con `dsc_int_siguiente`.
-   `latitud`: Float - Coordenada que indica la latitud de la ubicación del sensor.
-   `longitud`: Float - Coordenada que indica la longitud de la ubicación del sensor.

Sobre estos datos en particular, son *100 sensores* que se van cambiando de ubicacion mes a mes

## Base de Datos

Debido a que los datos utilizados, están estrechamente relacionados y a su vez son sumamente masivos, hemos decidido utilizar una base de datos relacionales.

```{r Coneccion a Base de Datos, include = FALSE}
con <- DBI::dbConnect(
  RPostgres::Postgres(),
  host = Sys.getenv("DB_HOST"),
  port = Sys.getenv("DB_PORT"),
  user = Sys.getenv("DB_USER"),
  password = Sys.getenv("DB_PASS"),
  dbname = Sys.getenv("DB_NAME")
)
```

![Diagrama de la base de datos](app/media/fct_registros.png "Diagrama de la base de datos"){width="300" height="600"}

En la base de datos la tabla principal es `fct_registros`

### Tabla: fct_registros

-   Cantidad de datos: 85386695
-   Variables de la tabla:
    -   *id_registros* (Primary Key)
    -   id_carril
    -   *id_fecha* -\> d_date(*id_fecha*) (Foreign Key)
    -   id_hora
    -   *id_detector* -\> d_sensores(*id_detector*) (Foreign Key)
    -   volume
    -   volumen_hora
    -   velocidad

### Tabla: d_sensores

-   Cantidad de datos: 273
-   Variables de la tabla:
    -   *id_detector* (Primary Key)
    -   dsc_avenida
    -   dsc_int_anterior
    -   dsc_int_siguiente
    -   latitud
    -   longitud
    -   barrio

### Tabla: d_date

-   Cantidad de datos: 3652
-   Variables de la tabla:
    -   *id_fecha* (Primary Key)
    -   date_actual
    -   epoch
    -   day_suffix
    -   day_name
    -   day_of_week
    -   day_of_month
    -   day_of_quarter
    -   day_of_year
    -   week_of_month
    -   week_of_year
    -   week_of_year_iso
    -   month_actual
    -   month_name
    -   month_name_abbreviated
    -   quarter_actual
    -   quarter_name
    -   year_actual
    -   first_day_of_week
    -   last_day_of_week
    -   first_day_of_month
    -   last_day_of_month
    -   first_day_of_quarter
    -   last_day_of_quarter
    -   first_day_of_year
    -   last_day_of_year
    -   mmyyyy
    -   mmddyyyy
    -   weekend_indr
    -   feriado

# Análisis exploratorio

```{r Cargar Mapas, sensores, semaforos, message=FALSE, results='hide'}
d_sensores <- DBI::dbGetQuery(
  con,
  "SELECT * FROM d_sensores"
  )
mvd_map <- load_geouy("Barrios")
mvd_map_fixed <- st_make_valid(st_transform(mvd_map, crs = 4326))
puntos_sensores <- d_sensores %>% 
  select(barrio, latitud, longitud) %>%
  mutate(transformarCoord(latitud, longitud, mvd_map))
capaSemafotos <- st_read(here::here('app',"data", "v_int_semaforos", "v_int_semaforos.shp"))

```

## Mapa de los datos
Para empezar mostraremos la superficie de Montevideo alcanzada por la informacion de los sensores de la intendencia.
Esta informacion no alcanza a todos los barrios , sino que solamente alcanza los siguientes barrios

```{r Cantidad de sensores por barrio, echo = FALSE}
cant_sensores <- d_sensores %>% group_by(barrio) %>% 
  summarise(
    cant_de_sensores = n()
    ) %>% 
  arrange(desc(cant_de_sensores))
print(cant_sensores)
```

En el siguiente mapa se puede visualizar

```{r Mapa de concentracion de sensores, echo = FALSE}
mvd_map_sensores <- mvd_map_fixed %>% 
  left_join(cant_sensores, by = c("nombbarr" = "barrio")) %>%
  mutate(cant_de_sensores = ifelse(is.na(cant_de_sensores), 0, cant_de_sensores))

ggplot() +
  geom_sf(
    data = mvd_map_sensores,
    aes(
      fill = ifelse(cant_de_sensores == 0, NA, cant_de_sensores)
    )
  ) +
  scale_fill_viridis_c(option = "plasma", name = "Cantidad de sensores por barrio") +
  theme_void() +
  theme(legend.position = "bottom")

```

\`\`\`

## Preguntas de investigación

1.  ¿Existe alguna correlación entre el volumen de tráfico y la velocidad promedio en las avenidas de Montevideo?
2.  ¿Cuáles son las calles con los mayores promedios de velocidad en Montevideo? ¿Con que frecuencia se cometen excesos de velocidad?
3. ¿Cómo va variando el volumen y velocidad medidos a través del TIEMPO?


## ¿Cuáles son las calles con los mayores promedios de velocidad en Montevideo? ¿Con que frecuencia se cometen excesos de velocidad?


Pasemos a investigar las calles con mayor promedio de velocidad.

```{r Importar datos de velocidad-calle, echo = FALSE }
velocidad_calles <- DBI::dbGetQuery(
  con,
  "
  SELECT d_sensores.dsc_avenida,
    AVG(velocidad) AS velocidad_promedio
  FROM fct_registros
  INNER JOIN d_sensores ON fct_registros.id_detector = d_sensores.id_detector
  GROUP BY dsc_avenida
  "
  )
```



```{r Calles con mayor promedio de velocidad, echo = FALSE, fig.cap="Calles con mayor promedio de velocidad"}
avenidas <- c("18 de Julio","8 de Octubre","Agraciada", "Av Brasil", "Av Italia","Bv Artigas","Bv Batlle y Ordonez","Bv Espana","C M Ramirez","Centenario","Fernandez Crespo","Bolivia","Albo","Belloni","Benito Blanco","Burges","Garibaldi","Garzon","Gral Flores","Millan","Morquio","Ponce","Rambla","Ricaldoni","Rivera","Rodo","San Martin","Saravia", "Soca","Uruguay","Varela", "L A de Herrera")  

velocidad_calles %>% 
  mutate(
    Tipo = ifelse(dsc_avenida %in% avenidas,
                  "Avenida", "Calle")
    ) %>% 
  arrange(desc(velocidad_promedio)) %>% 
  slice_head(n = 10) %>% 
  ggplot() +
  geom_col(
    aes(x = velocidad_promedio,
        y = reorder(dsc_avenida, velocidad_promedio),
        fill = Tipo) 
    ) +
  geom_text(
    aes( 
      x = velocidad_promedio, 
      y = dsc_avenida, 
      label = round(velocidad_promedio, 2)
    ),
    size = 5,
    nudge_x = 4,
  ) +
  labs(x = "Velocidad promedio",
       y = "Calle") +
  scale_fill_manual(
    values = c("Avenida" = "blue",
               "Calle" = "grey33")
    ) +
  theme_bw()
  
```

El siguiente gráfico nos muestra que las 3 calles con mas velocidad en promedio superan el máximo de 45km/h siendo este la velocidad máxima de circulación reglamentaria. La avenida más rápida en promedio no alcanza el máximo de velocidad perimitido

En promedio de velocidad circulacion los conductores son prudentes, aun asi vemos con que frecuencia se comenten excesos de velocidad.


```{r Importar datos de exceso de velocidad, echo=FALSE }
excesos <- DBI::dbGetQuery(
  con,
  "
  SELECT d_sensores.dsc_avenida,
    fct_registros.velocidad 
  FROM fct_registros TABLESAMPLE SYSTEM (10)
  JOIN d_sensores ON fct_registros.id_detector = d_sensores.id_detector
  "
  ) %>% 
  mutate(
    Tipo = ifelse(dsc_avenida %in% avenidas,
                  "Avenida", "Calle"),
    limite = ifelse(dsc_avenida %in% c("Bv Artigas",
                                       "Rambla",
                                       "Larranaga",
                                       "Bv Batlle y Ordonez",
                                       "Garzon"), 60, 45)
  )
```


```{r Grafico de , echo=FALSE, fig.cap = "Es netamente nula la proporcion de excesos de velocidad, podemos decir el los conductores en general respetan los limites de velocidad"}
excesos %>% 
  filter(velocidad > limite) %>% 
  group_by(dsc_avenida) %>%  
  summarise(
    cant = (n()/nrow(excesos))*100
    ) %>%
  arrange(desc(cant)) %>% 
  slice_head(n = 10) %>% 
  ggplot() +
  geom_col(
    aes(
      x = cant, 
      y = reorder(dsc_avenida, cant))
    ) + 
  geom_text(
    aes( 
      x = cant, 
      y = dsc_avenida, 
      label = paste(round(cant, 2),"%")
      ),
    size = 5,
    nudge_x = 0.15
  ) +
  labs(x = "Proporcion",
       y = "Calle") +
  theme_bw()
```




## ¿Cómo va variando el volumen y velocidad medidos a traves de el tiempo?

Observemos el volumen y la velocidad promedio de todos los días de la semana

```{r promedios_semanales, echo=FALSE}
promedios_semanales <- DBI::dbGetQuery(
  con,
  "
  WITH tabla as (
    SELECT
      d_date.day_of_week as dia,
      fct_registros.velocidad as velocidad,
      fct_registros.volume as volumen
    FROM fct_registros
    LEFT JOIN d_date ON fct_registros.id_fecha = d_date.id_fecha
    )
    
    
    SELECT
      avg(velocidad) as avg_velocidad,
      avg(volumen) as avg_volumen,
      dia
    FROM tabla 
    GROUP BY dia
    "
  ) %>%
  mutate( 
    dia_semana = 
      factor(
        dia,
        levels = c(1, 2, 3, 4, 5, 6, 7),
        labels = c("Lunes", "Martes", "Miercoles",
                   "Jueves", "Viernes", "Sabado", "Domingo")
        ) 
    ) %>% 
  pivot_longer(
    cols = c("avg_velocidad", "avg_volumen"),
    names_to = "variable",
    values_to = "promedio"
    ) %>%
  ggplot() +
  geom_col(
    aes(
      x = dia_semana,
      y = promedio,
      fill = variable
    ),
    position = "dodge"
  ) + 
  geom_text(
    aes( 
      x = dia_semana, 
      y = promedio, 
      label = round(promedio, 2) 
    ),
    position = position_dodge2(width = 1),
    vjust = -0.5
  ) +
  scale_fill_viridis_d(
    option = "plasma",
    name = "Variables:",
    labels = c("Velocidad", "Cantidad de vehiculos")
  ) +
  labs(
    x = "Dia de la semana",
    y = "Promedio"
  ) +
  theme_bw() +
  theme(
    legend.position = "bottom"
  ) 

promedios_semanales
```

En el gráfico se puede observar: - La velocidad media se mantiene casi constante durante toda la semana, salvo una leve variación positiva los fines de semana. - El volumen medio de vehículos detectados por los radares va variando en la semana, alcanzado su pico los viernes. También es considerablemente inferior los fines de semana.


Si bien previamente obsevamos leves exceos de velocidad, dentro de esos excesos se registran velocidades maximas de mas de 100km/h, veamos esos maximos pro franja horaria segun si fue registrado en un fin de semana o no
```{r, echo = FALSE}
registros_max_barrioxdiaxhora <- DBI::dbGetQuery(
    con,
    "
      SELECT
        d_date.day_of_week,
        d_date.day_name,
        d_date.month_actual,
        d_date.month_name,
        d_date.year_actual,
        d_date.weekend_indr,
        CASE
          WHEN fct_registros.id_hora >= 0 AND fct_registros.id_hora < 200 THEN '00:00 - 01:59'
          WHEN fct_registros.id_hora >= 200 AND fct_registros.id_hora < 400 THEN '02:00 - 03:59'
          WHEN fct_registros.id_hora >= 400 AND fct_registros.id_hora < 600 THEN '04:00 - 05:59'
          WHEN fct_registros.id_hora >= 600 AND fct_registros.id_hora < 800 THEN '06:00 - 07:59'
          WHEN fct_registros.id_hora >= 800 AND fct_registros.id_hora < 1000 THEN '08:00 - 09:59'
          WHEN fct_registros.id_hora >= 1000 AND fct_registros.id_hora < 1200 THEN '10:00 - 11:59'
          WHEN fct_registros.id_hora >= 1200 AND fct_registros.id_hora < 1400 THEN '12:00 - 13:59'
          WHEN fct_registros.id_hora >= 1400 AND fct_registros.id_hora < 1600 THEN '14:00 - 15:59'
          WHEN fct_registros.id_hora >= 1600 AND fct_registros.id_hora < 1800 THEN '16:00 - 17:59'
          WHEN fct_registros.id_hora >= 1800 AND fct_registros.id_hora < 2000 THEN '18:00 - 19:59'
          WHEN fct_registros.id_hora >= 2000 AND fct_registros.id_hora < 2200 THEN '20:00 - 21:59'
          WHEN fct_registros.id_hora >= 2200 AND fct_registros.id_hora <= 2359 THEN '22:00 - 23:59'
          ELSE 'Unknown'
        END AS hora_rango,
        MAX(fct_registros.velocidad) AS max_velocidad,
        MAX(fct_registros.volume) AS max_volumen,
        AVG(fct_registros.velocidad) AS promedio_velocidad,
        AVG(fct_registros.volume) AS promedio_volumen,
        MAX(fct_registros.volumen_hora) as max_volumen_hora,
        AVG(fct_registros.volumen_hora) as promedio_volumen_hora,
        COUNT(fct_registros.velocidad) AS cant_registros
    FROM fct_registros
    INNER JOIN d_sensores ON fct_registros.id_detector = d_sensores.id_detector
    LEFT JOIN d_date ON fct_registros.id_fecha = d_date.id_fecha
    GROUP BY d_date.day_of_week, hora_rango, d_date.month_actual, d_date.year_actual, d_date.weekend_indr, d_date.day_name, d_date.month_name
    "
  )

mediana <- registros_max_barrioxdiaxhora %>% 
  summarise(mediana = median(max_velocidad))
mediana <- as.numeric(mediana)

registros_max_barrioxdiaxhora %>%
  ggplot(
    aes(
      x = max_velocidad,
      y = fct_rev(hora_rango)
    )
  ) +
  geom_boxplot() +
  geom_point(
    position = position_jitter(w=0, h=0.2),
    alpha = 0.2,
    aes(color = day_name)
  ) +
  stat_summary(fun = mean, geom = "point", size = 3, alpha = 0.6) +
  geom_vline(xintercept = mediana) +
  facet_grid(~weekend_indr)
```
Entre las 00:00 y las 08:00 es donde se alcanzan picos de casi 140 km/h, luego de ese rango se reduce la tendencia por ser horario laboral para luego crecer a medida de que cae la noche.
Durante el fin de semana las velocidades máximas durante el horario laboral de lunes a viernes es totalmente diferente, los conductores durante el fin de semana aprovechan la baja de volumen para circular mas rápido.


Si entramos en cada año vemos como crece la densidad de velocidad máxima registrada de lunes a viernes, 
```{r, echo = FALSE, fig.cap = '2023 no esta completo, vamos a profundizar mas en nuestro modelo predictivo'}
registros_max_barrioxdiaxhora %>%
  ggplot(
    aes(
      x =  max_velocidad,
      fill = weekend_indr
    )
  ) +
  geom_density(alpha = 0.5) +
  facet_grid(~year_actual) +
  theme(legend.position = "bottom")
```

Ahora la desidad de velocidad durante los dias siempre se encuentran en un rango de (0,60]
```{r, echo = FALSE}
tabla <- DBI::dbGetQuery(
  con,
  "
  SELECT
    fct_registros.volume, 
    fct_registros.velocidad,
    d_date.day_of_week
  FROM
    fct_registros TABLESAMPLE SYSTEM (0.5)
  INNER JOIN 
    d_sensores ON fct_registros.id_detector = d_sensores.id_detector
  INNER JOIN 
    d_date ON fct_registros.id_fecha = d_date.id_fecha
  WHERE
    fct_registros.velocidad <> 0 AND fct_registros.volume <> 0

  "
) %>% 
  mutate( 
    dia_de_la_semana = 
      factor(
        day_of_week,
        levels = c(1, 2, 3, 4, 5, 6, 7),
        labels = c("Lunes", "Martes", "Miercoles", "Jueves", "Viernes", "Sabado", "Domingo")
      )
  )

tabla %>%
  ggplot() + 
  geom_density(
    aes(x = velocidad)
  ) +
  facet_wrap(~dia_de_la_semana) + 
  scale_x_continuous(breaks = seq(0, 150, 20),
                     name = "Velocidad"
  ) +
  scale_y_continuous(
    name= "Cantidad"
  )
```

Con el volumen de trafico, hay una gran diferencia el domingo comparado con el resto de los dias, en todos los dias la mayoria de volumen se concentra en el rango (0,10] donde en dicho rango alcanza su pico de circulacion en todo Montevideo.
```{r, echo = FALSE}
tabla %>%
  ggplot() + 
  geom_density(
    aes(x = volume)
  ) +
  facet_wrap(~dia_de_la_semana) +
  scale_x_continuous(
    name = "Volumen",
    breaks = seq(0,100,10)
  ) +
  scale_y_continuous(
    name= "Cantidad"
  ) +
  coord_cartesian(xlim = c(0, 100))
```

```{r va esto??, eval=FALSE}
maxVolumen_diaSemana_barrio <- DBI::dbGetQuery(
    con,
    "
    SELECT
      d_sensores.barrio,
      d_date.day_of_week,
      MAX(fct_registros.volume) AS max_volumen,
      COUNT(fct_registros.volume) AS cant_registros
    FROM fct_registros
    INNER JOIN d_sensores ON
      fct_registros.id_detector = d_sensores.id_detector
    LEFT JOIN d_date ON
      fct_registros.id_fecha = d_date.id_fecha
    GROUP BY d_sensores.barrio, d_date.day_of_week
    "
  ) %>% mutate(
    variacionConMedia = max_volumen - mean(max_volumen)
  )

```

```{r va esto?, eval=FALSE}
maxVolumen_diaSemana_barrio %>%
  ggplot(
    aes(
      x = barrio,
      y = day_of_week,
      fill = variacionConMedia
    )
  ) +
  geom_tile(color = "white",
            lwd = 1.5,
            linetype = 1) +
  coord_fixed() +
  coord_flip()
```

La verdad que no veo nada interesante, mas alla que cerrito es muy dispar al resto

## Resultados interesantes

[Presentar los resultados más relevantes obtenidos durante el análisis exploratorio.]

# Modelo estadístico

## Variables

[Describir la variable de respuesta y las variables explicativas utilizadas.]

## Elección del modelo

Intentaremos predecir como sera la velocidad en lo que queda del 2023

```{r, eval = FALSE}
arbol <- DBI::dbGetQuery(
    con,
    "
    SELECT
      d_sensores.dsc_avenida,
      d_sensores.barrio,
      fct_registros.volumen_hora,
      fct_registros.volume,
      fct_registros.velocidad
    FROM d_sensores
    INNER JOIN fct_registros ON d_sensores.id_detector = fct_registros.id_detector
    "
    )
```

## Ajuste y evaluación

[Ajustar el modelo con el conjunto de entrenamiento y evaluarlo con el conjunto de prueba.]

## Predicciones

[Presentar las predicciones realizadas por el modelo.]

## Interpretación de resultados

[Interpretar los resultados obtenidos del modelo estadístico.]

# Aplicación Shiny

## Descripción

La aplicación consta de 4 partes. Un mapa con la ubicación de los semáforos, un analisis univariado, otro multivariado y el modelo.
La palicacion resume todo lo hecho anteriormente.
[Enlace](https://ivan1arriola.shinyapps.io/tareaFinal/)


# Comentarios finales

## Hallazgos principales

[Resumir los principales hallazgos del proyecto.]

## Posibles extensiones

[Discutir posibles extensiones o mejoras para el proyecto.]

<<<<<<< HEAD
```{r}
registros_max_barrioxdiaxhora <- DBI::dbGetQuery(
    con,
    "
      SELECT
        d_date.day_of_week,
        d_date.month_actual,
        d_date.year_actual,
        d_date.weekend_indr,
        CASE
            WHEN fct_registros.id_hora >= 0 AND fct_registros.id_hora < 200 THEN '00:00 - 01:59'
            WHEN fct_registros.id_hora >= 200 AND fct_registros.id_hora < 400 THEN '02:00 - 03:59'
            WHEN fct_registros.id_hora >= 400 AND fct_registros.id_hora < 600 THEN '04:00 - 05:59'
            WHEN fct_registros.id_hora >= 600 AND fct_registros.id_hora < 800 THEN '06:00 - 07:59'
            WHEN fct_registros.id_hora >= 800 AND fct_registros.id_hora < 1000 THEN '08:00 - 09:59'
            WHEN fct_registros.id_hora >= 1000 AND fct_registros.id_hora < 1200 THEN '10:00 - 11:59'
            WHEN fct_registros.id_hora >= 1200 AND fct_registros.id_hora < 1400 THEN '12:00 - 13:59'
            WHEN fct_registros.id_hora >= 1400 AND fct_registros.id_hora < 1600 THEN '14:00 - 15:59'
            WHEN fct_registros.id_hora >= 1600 AND fct_registros.id_hora < 1800 THEN '16:00 - 17:59'
            WHEN fct_registros.id_hora >= 1800 AND fct_registros.id_hora < 2000 THEN '18:00 - 19:59'
            WHEN fct_registros.id_hora >= 2000 AND fct_registros.id_hora < 2200 THEN '20:00 - 21:59'
            WHEN fct_registros.id_hora >= 2200 AND fct_registros.id_hora <= 2359 THEN '22:00 - 23:59'
            ELSE 'Unknown'
        END AS hora_rango,
        MAX(fct_registros.velocidad) AS max_velocidad,
        MAX(fct_registros.volume) AS max_volumen,
        AVG(fct_registros.velocidad) AS promedio_velocidad,
        AVG(fct_registros.volume) AS promedio_volumen,
        MAX(fct_registros.volumen_hora) as max_volumen_hora,
        AVG(fct_registros.volumen_hora) as promedio_volumen_hora,
        COUNT(fct_registros.velocidad) AS cant_registros
    FROM fct_registros
    INNER JOIN d_sensores ON fct_registros.id_detector = d_sensores.id_detector
    LEFT JOIN d_date ON fct_registros.id_fecha = d_date.id_fecha
    GROUP BY d_date.day_of_week, hora_rango, d_date.month_actual, d_date.year_actual, d_date.weekend_indr
    "
  )


```


```{r}

registros_max_barrioxdiaxhora <- registros_max_barrioxdiaxhora %>% 
  mutate( 
    esFinDeSemana = weekend_indr,
    dia_de_la_semana = 
      factor(
        day_of_week,
        levels = c(1, 2, 3, 4, 5, 6, 7),
        labels = c("Lunes", "Martes", "Miercoles", "Jueves", "Viernes", "Sabado", "Domingo")
      ),
    hora_rango = factor(
      hora_rango,
      levels = c(
        "00:00 - 01:59", "02:00 - 03:59", "04:00 - 05:59", "06:00 - 07:59", "08:00 - 09:59",
        "10:00 - 11:59", "12:00 - 13:59", "14:00 - 15:59", "16:00 - 17:59", "18:00 - 19:59",
        "20:00 - 21:59", "22:00 - 23:59", "Unknown"
      ),
      labels = c(
        "00:00 - 01:59", "02:00 - 03:59", "04:00 - 05:59", "06:00 - 07:59", "08:00 - 09:59",
        "10:00 - 11:59", "12:00 - 13:59", "14:00 - 15:59", "16:00 - 17:59", "18:00 - 19:59",
        "20:00 - 21:59", "22:00 - 23:59", "Unknown"
      )
    ),
    mes = factor(
      month_actual,
      levels = 1:12,
      labels = c(
        "Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
        "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
      )
    )
  )


```

```{r}
registros_max_barrioxdiaxhora %>%
  ggplot(
    aes(
      x =  max_velocidad,
      y = forcats::fct_rev(hora_rango )
    )
  ) +
  geom_boxplot() +
  geom_point(
    position = position_jitter(w=0, h=0.2),
    alpha = 0.2,
    aes(color = dia_de_la_semana)
  ) +
  stat_summary(fun = mean, geom = "point", size = 3, alpha = 0.6) +
  facet_grid(~esFinDeSemana)


  
```

```{r}
registros_max_barrioxdiaxhora %>%
  ggplot(
    aes(
      x =  max_velocidad,
      fill = esFinDeSemana # esto añade el color según el factor esFinDeSemana
    )
  ) +
  geom_density(alpha = 0.5) +
  facet_grid(~year_actual)
  

```

```{r}
registros_max_barrioxdiaxhora %>%
  ggplot(
    aes(
      x =  max_velocidad,
      fill = esFinDeSemana # esto añade el color según el factor esFinDeSemana
    )
  ) +
  geom_density(alpha = 0.5) +
  facet_wrap(~month_actual)
  

```
Se observa un pico en Agosto
Dia de la nostalgia?


```{r}
(
  registros_año_mes <- DBI::dbGetQuery(
    con,
    "
       SELECT
        count(*),
    d_date.month_actual, d_date.year_actual
    FROM fct_registros
    LEFT JOIN d_date ON fct_registros.id_fecha = d_date.id_fecha
    GROUP BY d_date.month_actual, d_date.year_actual

    "
  )
)
```

Haciendo una observacion de los meses cubiertos por los datos, nos hemos dado cuenta que Agosto solo esta representado por los datos del 2021.




```{r, eval=FALSE}
registros_Agosto <- registros_Agosto %>% 
  dplyr::mutate( 
    dia_de_la_semana = 
      factor(
        day_of_week,
        levels = c(1, 2, 3, 4, 5, 6, 7),
        labels = c("Lunes", "Martes", "Miercoles", "Jueves", "Viernes", "Sabado", "Domingo")
      )
  )

```


```{r, eval=FALSE}
registros_Agosto %>%  filter(year_actual == 2022)  %>%
  ggplot(
    aes(
      x =  day_of_month,
      fill = dia_de_la_semana
    )
  ) +
  geom_col(
    aes(
      y = max_volumen_hora,
    )
  ) +
  scale_x_continuous(
    breaks = 1:31
  )
  
```


### Referencias



## .¿Existe alguna correlación entre el volumen de tráfico y la velocidad promedio en las avenidas de Montevideo?

```{r Importar velocidad - fecha - volumen - avenida  , eval=FALSE}
(
  promediosMarzo23 <- DBI::dbGetQuery(
    con,
    "
      WITH velocidad_volumen_enero_2023 AS (
  SELECT
    fct_registros.velocidad,
    fct_registros.volume,
    d_sensores.dsc_avenida, 
    d_date.year_actual
  FROM fct_registros
  LEFT JOIN d_sensores ON fct_registros.id_detector = d_sensores.id_detector
  LEFT JOIN d_date ON fct_registros.id_fecha = d_date.id_fecha
),
promedios_marzo_23 AS (
  SELECT
    dsc_avenida,
    year_actual,
    AVG(velocidad) AS velocidad_media,
    AVG(volume) AS volumen_media
  FROM velocidad_volumen_enero_2023
  GROUP BY dsc_avenida, year_actual
)
SELECT *
FROM promedios_marzo_23

    "
  )
)

```

```{r , eval=FALSE}
promediosMarzo23 %>% 
  ggplot(
    aes(
      x = velocidad_media,
      y = volumen_media
    )
  ) +
  geom_point() + 
  facet_wrap(~year_actual) +
  scale_x_continuous(name = "Velocidad Media Anual") +
  scale_y_continuous(name = "Volumen de Vehiculos Medio Anual") +
  geom_smooth(method = lm)
    
  
promediosMarzo23 %>% group_by(year_actual) %>% 
  summarise(
    correlacion = cor(velocidad_media, volumen_media)
  )
```

El grafico no muestra una relacion aparente entre los promedios de las variables

# Muestra aleatoria de volumen y velocidad, agregados por dia de la semana
Vamos a analizar la relacion entre el volumen de trefico, la velocidad, el dia de la semana y el barrio donde se encuentra el sensor


```{r}
tabla <- DBI::dbGetQuery(
  con,
  "
  SELECT
    fct_registros.volume, 
    fct_registros.velocidad,
    d_date.day_of_week
  FROM
    fct_registros TABLESAMPLE SYSTEM (0.5)
  INNER JOIN 
    d_sensores ON fct_registros.id_detector = d_sensores.id_detector
  INNER JOIN 
    d_date ON fct_registros.id_fecha = d_date.id_fecha
  WHERE
    fct_registros.velocidad <> 0 AND fct_registros.volume <> 0

  "
) %>% 
  dplyr::mutate( 
    dia_de_la_semana = 
      factor(
        day_of_week,
        levels = c(1, 2, 3, 4, 5, 6, 7),
        labels = c("Lunes", "Martes", "Miercoles", "Jueves", "Viernes", "Sabado", "Domingo")
      )
  )
```


```{r}
tabla %>%
  ggplot() + 
  geom_density(
    aes(x = velocidad)
  ) +
  facet_wrap(~dia_de_la_semana) + 
  scale_x_continuous(breaks = seq(0, 150, 20),
                     name = "Velocidad"
  ) +
  scale_y_continuous(
    name= "Cantidad"
  )
```


```{r}
tabla %>%
  ggplot() + 
  geom_density(
    aes(x = volume)
  ) +
  facet_wrap(~dia_de_la_semana) +
  scale_x_continuous(
    breaks = seq(0, 400, 50),
    name = "Volumen"
  ) +
  scale_y_continuous(
    name= "Cantidad"
  )
```






